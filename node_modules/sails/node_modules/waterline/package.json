{
  "name": "waterline",
  "description": "An ORM for Node.js and the Sails framework",
  "version": "0.10.0",
  "homepage": "http://github.com/balderdashy/waterline",
  "contributors": [
    {
      "name": "particlebanana"
    },
    {
      "name": "mikermcneil"
    },
    {
      "name": "zolmeister"
    }
  ],
  "dependencies": {
    "lodash": "~2.4.1",
    "async": "~0.2.9",
    "anchor": "~0.9.7",
    "q": "~0.9.7",
    "waterline-schema": "~0.1.0",
    "node-switchback": "~0.0.4"
  },
  "devDependencies": {
    "mocha": "1.9.x",
    "should": "~2.1.1"
  },
  "keywords": [
    "mvc",
    "orm",
    "mysql",
    "postgresql",
    "redis",
    "mongodb",
    "active-record",
    "waterline",
    "sails",
    "sails.js"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/balderdashy/waterline.git"
  },
  "main": "./lib/waterline",
  "scripts": {
    "test": "mocha test --recursive",
    "prepublish": "npm prune",
    "browserify": "rm -rf .dist && mkdir .dist && browserify lib/waterline.js -s Waterline | uglifyjs > .dist/waterline.min.js"
  },
  "engines": {
    "node": "*"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/balderdashy/waterline/blob/master/LICENSE.md"
    }
  ],
  "bugs": {
    "url": "https://github.com/balderdashy/waterline/issues/new"
  },
  "gitHead": "8f308678b7ccf4f6354f4f2ee4bf93e431bd7644",
  "readme": "![image_squidhome@2x.png](http://i.imgur.com/7rMxw.png)\r\n\r\n# Waterline\r\n\r\n[![Build Status](https://travis-ci.org/balderdashy/waterline.png?branch=master)](https://travis-ci.org/balderdashy/waterline) [![NPM version](https://badge.fury.io/js/waterline.png)](http://badge.fury.io/js/waterline) [![Dependency Status](https://gemnasium.com/balderdashy/waterline.png)](https://gemnasium.com/balderdashy/waterline)\r\n\r\nWaterline is a brand new kind of storage and retrieval engine.\r\n\r\nIt provides a uniform API for accessing stuff from different kinds of databases, protocols, and 3rd party APIs. That means you write the same code to get users, whether they live in MySQL, LDAP, MongoDB, or Facebook.\r\n\r\nAt the same time, Waterline aims to learn lessons and maintain the best features from both Rails' ActiveRecord and Grails' Hibernate ORMs.\r\n\r\n## Installation\r\n\r\nInstall from NPM.\r\n\r\n```bash\r\n$ npm install waterline\r\n```\r\n\r\n## Example\r\n\r\n#### Using with Sails.js\r\n\r\nWaterline was extracted from the [Sails](https://github.com/balderdashy/sails) framework and is the default ORM used in Sails. For more information on using Waterline in your Sails App view the [Sails Docs](http://sailsjs.org).\r\n\r\nFor examples of how to use with frameworks such as [Express](http://expressjs.com/) look in the [Example](https://github.com/balderdashy/waterline/tree/master/example) folder.\r\n\r\n\r\n#### Usage (standalone)\r\n```javascript\r\nvar Waterline = require('waterline');\r\n\r\n// Define your collection (aka model)\r\nvar User = Waterline.Collection.extend({\r\n\r\n  attributes: {\r\n\r\n    firstName: {\r\n      type: 'string',\r\n      required: true\r\n    },\r\n\r\n    lastName: {\r\n      type: 'string',\r\n      required: true,\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n## Overview\r\n\r\n### Adapters Concept\r\n\r\nWaterline uses the concept of an Adapter to translate a predefined set of methods into a query that can be understood by your data store. Adapters allow you to use various datastores such as MySQL, PostgreSQL, MongoDB, Redis, etc. and have a clear API for working with your model data.\r\n\r\nIt also allows an adapter to define it's own methods that don't necessarily fit into the CRUD methods defined by default in Waterline. If an adapter defines a custom method, Waterline will simply pass the function arguments down to the adapter.\r\n\r\n**NOTE:** When using custom adapter methods the features of Waterline are not used. You no longer get the Lifecycle Callbacks and Validations as you would when using a defined Waterline method.\r\n\r\nYou may also supply an array of adapters and Waterline will map out the methods so they are both mixed in. It works similar to Underscore's [Extend](http://underscorejs.org/#extend) method where the last item in the array will override any methods in adapters before it. This allows you to mixin bothe traditional CRUD adapters such as MySQL with specialized adapters such as Twilio and have both types of methods available.\r\n\r\n#### Community Adapters\r\n\r\n  - [PostgreSQL](https://github.com/particlebanana/sails-postgresql) - *0.9+ compatible*\r\n  - [MySQL](https://github.com/balderdashy/sails-mysql) - *0.9+ compatible*\r\n  - [MongoDB](https://github.com/balderdashy/sails-mongo) - *0.9+ compatible*\r\n  - [Memory](https://github.com/balderdashy/sails-memory) - *0.9+ compatible*\r\n  - [Disk](https://github.com/balderdashy/sails-disk) - *0.9+ compatible*\r\n  - [Redis](https://github.com/balderdashy/sails-redis)\r\n  - [Riak](https://github.com/balderdashy/sails-riak)\r\n  - [IRC](https://github.com/balderdashy/sails-irc)\r\n  - [Twitter](https://github.com/balderdashy/sails-twitter)\r\n  - [JSDom](https://github.com/mikermcneil/sails-jsdom)\r\n\r\n## Collection\r\n\r\nA [Collection](https://github.com/balderdashy/waterline/blob/master/lib/waterline/collection/index.js) is the main object used in Waterline. It defines the layout/schema of your data along with any validations and instance methods you create.\r\n\r\nTo create a new collection you extend `Waterline.Collection` and add in any properties you need.\r\n\r\n#### options\r\n\r\nAvailable options are\r\n\r\n  - `tableName` Define a custom table name to store the models\r\n  - `adapter` the name of the adapter you would like to use for this collection\r\n  - `schema`  Set schema true/false to only allow fields defined in `attributes` to be saved. Only for schemaless adapters.\r\n  - `attributes` A hash of attributes to be defined for a model\r\n  - `autoCreatedAt` and `autoUpdateddAt` Set false to prevent creating `createdAt` and `updatedAt` properties in your model\r\n  - `autoPK` Set false to prevent creating `id`. By default `id` will be created as index with auto increment\r\n  - [lifecyle callbacks](#lifecycle-callbacks)\r\n  - anyother class method you define!\r\n\r\n#### Attributes\r\n\r\nThe following attribute types are currently available:\r\n\r\n  - string\r\n  - text\r\n  - integer\r\n  - float\r\n  - date\r\n  - time\r\n  - datetime\r\n  - boolean\r\n  - binary\r\n  - array\r\n  - json\r\n\r\n#### Example Collection\r\n\r\n```javascript\r\nvar User = Waterline.Collection.extend({\r\n\r\n  // Define a custom table name\r\n  tableName: 'user',\r\n\r\n  // Set schema true/false for adapters that support schemaless\r\n  schema: true,\r\n\r\n  // Define an adapter to use\r\n  adapter: 'postgresql',\r\n\r\n  // Define attributes for this collection\r\n  attributes: {\r\n\r\n    firstName: {\r\n      type: 'string',\r\n\r\n      // also accepts any validations\r\n      required: true\r\n    },\r\n\r\n    lastName: {\r\n      type: 'string',\r\n      required: true,\r\n      maxLength: 20\r\n    },\r\n\r\n    email: {\r\n\r\n      // Special types are allowed, they are used in validations and\r\n      // set as a string when passed to an adapter\r\n      type: 'email',\r\n\r\n      required: true\r\n    },\r\n\r\n    age: {\r\n      type: 'integer',\r\n      min: 18\r\n    },\r\n\r\n    // You can also define instance methods here\r\n    fullName: function() {\r\n      return this.firstName + ' ' + this.lastName\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Lifecycle Callbacks\r\n   *\r\n   * Run before and after various stages:\r\n   *\r\n   * beforeValidation\r\n   * afterValidation\r\n   * beforeUpdate\r\n   * afterUpdate\r\n   * beforeCreate\r\n   * afterCreate\r\n   * beforeDestroy\r\n   * afterDestroy\r\n   */\r\n\r\n  beforeCreate: function(values, cb) {\r\n\r\n    // an example encrypt function defined somewhere\r\n    encrypt(values.password, function(err, password) {\r\n      if(err) return cb(err);\r\n\r\n      values.password = password;\r\n      cb();\r\n    });\r\n  },\r\n\r\n  // Class Method\r\n  doSomething: function() {\r\n    // do something here\r\n  }\r\n\r\n});\r\n```\r\n\r\nNow that a collection is defined we can instantiate it and begin executing queries against it. All Collections take `options` and `callback` arguments.\r\n\r\nOptions will be made up of:\r\n\r\n  - `tableName`, used if not defined in a Collection definition\r\n  - `adapters` object that specifies each adapter, either custom definitions or from NPM\r\n\r\n```javascript\r\nvar postgres = require('sails-postgresql');\r\n\r\nnew User({ tableName: 'foobar', adapters: { postgresql: postgres }}, function(err, Model) {\r\n\r\n  // We now have an instantiated collection to execute queries against\r\n  Model.find()\r\n  .where({ age: 21 })\r\n  .limit(10)\r\n  .exec(function(err, users) {\r\n    // Now we have an array of users\r\n  });\r\n\r\n});\r\n```\r\n\r\n## Model\r\n\r\nEach result that gets returned from a Waterline query will be an instance of [Model](https://github.com/balderdashy/waterline/blob/master/lib/waterline/model/index.js). This will add in any instance methods defined in your collection along with some CRUD helper methods. View the [Core Instance Methods](https://github.com/balderdashy/waterline/blob/master/lib/waterline/model/index.js) to see how they are implemented.\r\n\r\nDefault CRUD instance methods:\r\n\r\n  - save\r\n  - destroy\r\n  - toObject\r\n  - toJSON\r\n\r\nIf you would like to filter records and remove certain attributes you can override the `toJSON` method like so:\r\n\r\n```javascript\r\nvar user = Waterline.Collection.extend({\r\n\r\n  attributes: {\r\n    name: 'string',\r\n    password: 'string',\r\n\r\n    // Override toJSON instance method\r\n    toJSON: function() {\r\n      var obj = this.toObject();\r\n      delete obj.password;\r\n      return obj;\r\n    }\r\n  }\r\n});\r\n\r\n// Then on an instantiated user:\r\nuser.find({ id: 1}).exec(function(err, model) {\r\n  return model.toJSON(); // will return only the name\r\n});\r\n```\r\n\r\n## Query Methods\r\n\r\nQueries can be run with either a callback interface or with a deferred object. For building complicated queries the deferred object method is the best choice. For convenience, promises are supported by default.\r\n\r\n**Callback Method**\r\n\r\n```javascript\r\nUser.findOne({ id: 1 }, function(err, user) {\r\n  // Do stuff here\r\n});\r\n```\r\n\r\n**Deferred Object Method**\r\n\r\n```javascript\r\nUser.find()\r\n.where({ id: { '>': 100 }})\r\n.where({ age: 21 })\r\n.limit(100)\r\n.sort('name')\r\n.exec(function(err, users) {\r\n  // Do stuff here\r\n});\r\n```\r\n\r\n**Promises**\r\n\r\n```javascript\r\nUser.findOne()\r\n.where({ id: 2 })\r\n.then(function(user){\r\n    var comments = Comment.find({userId: user.id}).then(function(comments){\r\n        return comments;\r\n    });\r\n    return [user.id, user.friendsList, comments];\r\n}).spread(function(userId, friendsList, comments){\r\n    // Promises are awesome!\r\n}).fail(function(err){\r\n    // An error occured\r\n})\r\n```\r\nPromises use the [Q library](https://github.com/kriskowal/q), so anything you do after the first `then` call (or `spread`, or `fail`), will be a complete Q promise object. Remember, you must end the query somehow (by calling `then` or one of the other functions) in order to complete the database request.\r\n\r\nEach of the following basic methods are available by default on a Collection instance.\r\n\r\n  - findOne\r\n  - find\r\n  - create\r\n  - update\r\n  - destroy\r\n  - count\r\n\r\nIn addition you also have the following helper methods:\r\n\r\n  - createEach\r\n  - findOrCreateEach\r\n  - findOrCreate\r\n  - findOneLike\r\n  - findLike\r\n  - startsWith\r\n  - endsWith\r\n  - contains\r\n\r\nBased on your Collection attributes you also have dynamic finders. So given a `name` attribute the following queries will be available:\r\n\r\n  - findOneByName\r\n  - findOneByNameIn\r\n  - findOneByNameLike\r\n  - findByName\r\n  - findByNameIn\r\n  - findByNameLike\r\n  - countByName\r\n  - countByNameIn\r\n  - countByNameLike\r\n  - nameStartsWith\r\n  - nameEndsWith\r\n  - nameContains\r\n\r\n## Pagination\r\n\r\nIn addition to the other find methods, there are a few helper methods to take care of pagination:\r\n\r\n  - skip\r\n  - limit\r\n  - paginate\r\n\r\nSkip takes an integer and can be used to skip records:\r\n\r\n``` javascript\r\nUser.find().skip(20);\r\n```\r\n\r\nLimit takes an integer and limits the amount of records returned:\r\n\r\n``` javascript\r\nUser.find().limit(10);\r\n```\r\n\r\nAnd put together they create the ability to paginate through records as you would pages. For example, if I wanted 'page 2' of a given record set, and I only want to see 10 records at a time, I know that I need to ```skip(10)``` and ```limit(10)``` like so:\r\n\r\n``` javascript\r\nUser.find().skip(10).limit(10);\r\n```\r\n\r\nBut, while we are thinking in terms of pagination, or pages, it might be easier to use the final helper - paginate:\r\n\r\n``` javascript\r\nUser.find().paginate({page: 2, limit: 10});\r\n```\r\n\r\nPaginate has several options:\r\n\r\n  - ```paginate()``` defaults options to ```{page: 0, limit: 10}```\r\n  - ```paginate({page: 2})``` uses ```{page: 2, limit: 10}``` as the options\r\n  - ```paginate({limit: 20})``` uses ```{page: 0, limit: 20}``` as the options\r\n  - ```paginate({page: 1, limit: 20})``` uses ```{page: 1, limit: 20}``` as the options\r\n\r\nIt returns a deferred object so that you can continue to chain your helpers.\r\n\r\n## Sorting\r\n\r\nSorting can be performed in the deferred object query method `sort` or by adding the sort key into the criteria object. Simply specify an attribute name for natural (ascending) sort, or specify an `asc` or `desc` flag for ascending or descending orders respectively.\r\n\r\n```javascript\r\nUser.find()\r\n.sort('roleId asc')\r\n.sort({ createdAt: 'desc' })\r\n.exec(function(err, users) {\r\n  // Do stuff here\r\n});\r\n```\r\n\r\n\r\n## Validations\r\n\r\nValidations are handled by [Anchor](https://github.com/balderdashy/anchor) which is based off of [Node Validate](https://github.com/chriso/node-validator) and supports most of the properties in node-validate. For a full list of validations see: [Anchor Validations](https://github.com/balderdashy/anchor/blob/master/lib/rules.js).\r\n\r\nValidations are defined directly in you Collection attributes. In addition you may set the attribute `type` to any supported Anchor type and Waterline will build a validation and set the schema type as a string for that attribute.\r\n\r\nValidation rules may be defined as simple values or functions (both sync and async) that return the value to test against.\r\n\r\n```javascript\r\nvar User = Waterline.Collection.extend({\r\n\r\n  attributes: {\r\n\r\n    firstName: {\r\n      type: 'string',\r\n      required: true,\r\n      minLength: 5,\r\n      maxLength: 15\r\n    },\r\n\r\n    lastName: {\r\n      type: 'string',\r\n      required: true,\r\n      minLength: 5,\r\n      maxLength: 100\r\n    },\r\n\r\n    age: {\r\n      type: 'integer',\r\n      after: '12/12/2001'\r\n    },\r\n\r\n    website: {\r\n      type: 'string',\r\n      // Validation rule may be defined as a function. Here, an async function is mimicked.\r\n      contains: function(cb) {\r\n        setTimeout(function() {\r\n          cb('http://');\r\n        }, 1);\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\nvar Event = Waterline.Collection.extend({\r\n\r\n  attributes: {\r\n\r\n    startDate: {\r\n      type: 'date',\r\n      // Validation rule functions allow you to validate values against other attributes\r\n      before: function() {\r\n        return this.endDate;\r\n      }\r\n    },\r\n\r\n    endDate: {\r\n      type: 'date',\r\n      after: function() {\r\n        return this.startDate;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n}\r\n```\r\n## Custom Types\r\nYou can define your own types and their validation with the `types` hash. It's possible to access and compare values to other attributes.\r\n\r\n```javascript\r\nvar User = Waterline.Collection.extend({\r\n  types: {\r\n    point: function(latlng){\r\n     return latlng.x && latlng.y\r\n    },\r\n\r\n    password: function(password) {\r\n      return password === this.passwordConfirmation;\r\n    });\r\n  },\r\n\r\n  attributes: {\r\n    firstName: {\r\n      type: 'string',\r\n      required: true,\r\n      minLength: 5,\r\n      maxLength: 15\r\n    },\r\n\r\n    location: {\r\n      //note, that the base type (json) still has to be define\r\n      type: 'json',\r\n      point: true\r\n    },\r\n\r\n    password: {\r\n      type: 'string',\r\n      password: true\r\n    },\r\n\r\n    passwordConfirmation: {\r\n      type: 'string'\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n## Indexing\r\n\r\nYou can add an index property to any attribute to create an index if your adapter supports it. This comes in handy when performing repeated queries\r\nagainst a key.\r\n\r\n```javascript\r\nvar User = Waterline.Collection.extend({\r\n\r\n  attributes: {\r\n\r\n    serviceID: {\r\n      type: 'integer',\r\n      index: true\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nCurrently Waterline doesn't support multi-column indexes in the attributes definition. If you would like to build any sort of special index you will still\r\nneed to build that manually. Also note when adding a `unique` property to an attribute an index will automatically be created for that attribute so there is no\r\nneed to specifiy it.\r\n\r\nThere is currently an issue with adding indexes to string fields. Because Waterline performs it's queries in a case insensitive manner we are unable to use the index on a string attribute. There are some workarounds being discussed but nothing is implemented so far. This will be updated in the near future to fully support indexes on strings.\r\n\r\n## Lifecycle Callbacks\r\n\r\nLifecycle callbacks are functions you can define to run at certain times in a query. They are useful for mutating data before creating or generating properties before they are validated.\r\n\r\n**Callbacks run on Create**\r\n\r\n  - beforeValidation / *fn(values, cb)*\r\n  - afterValidation / *fn(values, cb)*\r\n  - beforeCreate / *fn(values, cb)*\r\n  - afterCreate / *fn(newlyInsertedRecord, cb)*\r\n\r\n**Callbacks run on Update**\r\n\r\n  - beforeValidation / *fn(valuesToUpdate, cb)*\r\n  - afterValidation / *fn(valuesToUpdate, cb)*\r\n  - beforeUpdate / *fn(valuesToUpdate, cb)*\r\n  - afterUpdate / *fn(updatedRecord, cb)*\r\n\r\n**Callbacks run on Destroy**\r\n\r\n  - beforeDestroy / *fn(criteria, cb)*\r\n  - afterDestroy / *fn(cb)*\r\n\r\n## Tests\r\n\r\nAll tests are written with [mocha](http://visionmedia.github.com/mocha/) and should be run with [npm](http://npmjs.org):\r\n\r\n``` bash\r\n  $ npm test\r\n```\r\n",
  "readmeFilename": "README.md",
  "_id": "waterline@0.10.0",
  "_shasum": "fde67a819ab3c28c76cd553d9853333d986ca809",
  "_from": "git://github.com/balderdashy/waterline.git#v0.10",
  "_resolved": "git://github.com/balderdashy/waterline.git#8f308678b7ccf4f6354f4f2ee4bf93e431bd7644",
  "_fromGithub": true
}
